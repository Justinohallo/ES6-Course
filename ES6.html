<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>let and const</title>
</head>
<body>
<ul>
    <li>Let variables are meant to be updated. Const variables are not meant to be updated. </li>
    <li>The properties of a const object can be changed. </li>
    <li> In an object, the object keys cannot be changed, but you can update the data. </li>
    <li> The object name represents something. The age of that something can change. You can update the age from 28 to 29. </li>
</ul>

<h3> Const and Let in the Real World </h3>

<ul>
    <li> Immediately invoked function expresion. Creates a scope and nothing will leak into the global scope. 
    </li>
    <li> Using var in an if statement creates a data leak.  </li>
</ul>

<h3> Temporal Dead Zone</h3>
<p>  If you try to console.log a variable before it is declared, it is undefined. The variable has been created but the data is undefined. 
    If you use let or const, you cannot access a variable before it has been created. 
</p>

<h3> Is Var dead? </h3>

<p> use const by default, use let only if you need to update the variable. Var should not be ever used. </p>
<p> Alternate opinion: Use let for localized variables in smaller scopes. It can be a pain to go back and update const to let when you realize you need to do it later. </p>

<h3> Arrow Functions </h3>
three main benefits 
<ol> 
    <li>Much more concise  </li>
    <li> Have implicit returns </li>
    <li> Doesn't rebind the value of this inside of another function. </li>
</ol>

<xmp> 
    const names = ['wes', 'kait', 'lux']

    const fullNames = names.map(function(name){
        return `${name} bos`
    })

    const fullNames2 = names.map((name) => {
        return `${name} bos`
    })

    const fullNames3 = names.map(name => {
        return `${name} bos`
        
    })

    const fullNames4 = names.map(name =>  `${name} bos`)
</xmp>

<p> We would like to take each name in the array above and add the last name bos to each array item. 
    We can do this using a normal function as described. Or we can use the fat arrow function, which replaces
    the "function" declaration to the other side of the paramater and uses a fat arrow. 
    
    In the third example, because we only have one paramater, we do not need to include parenthesis. We 
    can proceed using only the name of the paramater. 
    Arrow functions can also use an implicic return. An explicit return is when you explicitly say "return. "You can include what you return on one line, delete the return and curly brackets. 
    When you delete the curly brackets you are declaring an implicit return .
    

</p>
<p> Arrow functions are always an anomymous function. A named function is function sayMyName(name){ alert('Hello"}. 
    If you use an arrow function, you cannot name them. None of them have names. You can put them in a variable. 

</p>

<xmp> const sayMyName = (name) => {alert ('Hello ${name} ') </xmp>

<h3> More Arrow Functions Explained </h3>

If you take curly brackets off it is implicit return. You need to surround
the object literal in a. Map is a great function, as when you use it, you will
return a new list of items and properties. 

Filter will return an array based on a set of paramaters. 
<script> 
const race = '100 m dash'
const winners = [' Hunter Gath', 'Singa Song', 'Imda Bos']

const win = winners.map((winner, i)=> ({name: winner, race, place: i + 1 }))

const ages = [23, 62, 34, 56, 65, 34]

const old = ages.filter(age => age >= 60)
console.log(old)

</script>

<h3> Arrow Functions and This </h3>

<p>Most important function of arrow is that This is not rebound. When you 
    use a normal function, with the eventListener click you will receive
    the value of the element that is being selected. When you use an 
    arrow function, you will receive the Window information with THIS rather
    than the element information. 

    When you enter a new function and do not bind it to anything, it will be bound to the window. 
    When you have an arrow function, it inherits the value of THIS from a parent. 

    I would like to use this vanilla javascript on my Website project. 
</p>

<div class ='wrap'>
    <div class ='box'>
        <h2> Wes Bos</h2>
        <p class='social'> @wesbos</p>
    </div>
</div>

<script>
    const box = document.querySelector('.box')
    box.addEventListener('click', ()=> {
        this.classList.toggle('opening')
    })
</script>



<h3> Default Function Arguments</h3>

<p> You can declare a default paramater in the arguments. You 
    are able to pass in undefined when calling the function. This will 
    allow the function to work through. 
</p>
<script> 
function calculateBill(total, tax = 0.13, tip = 0.15){

    return total + (total * tax) + (total * tip)

}

const totalBill = calculateBill(100, 0.13, 0.15)
console.log(totalBill)

</script>


<h3> When not to use an arrow function </h3>
<script>
  function setWidth() {
    var width = 100;
    console.log(width);
  }
  setWidth();
  var age = 100;
  if(age > 12) {
    const dogYears = age * 7;
    console.log(`You are ${dogYears} dog years old!`);
  }
  let height = 200;
  const key = 'abc123';

let points = 50;
let winner = false

for(var i=0; i< 10; i++){
    setTimeout(function(){
console.log("The number is" + i)
    },1000)
}


</script>
</body>
</html>